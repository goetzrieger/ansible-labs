= Ansible Network Automation
:scrollbar:
:data-uri:
:toc: left
:numbered:
:icons: font
:imagesdir: ./images

== Structure (Draft)

. Start
  .. Presentation
  .. Inventories, Providers
    * explain principles
    * explain group vars and providers
    ** local_connection
    ** authentication, username, etc.
  .. ad-hoc
    * networking modules, generic vs specific
    * facts, ios_facts
    * {{ provider }}
    * ios_ping
    * ios_command
    ** first commands
    ** ev command chains
. Advanced
  .. Playbooks
    * backups
    * diffs against running or startup config
    * real world task:
    ** identify diff between two devices via backup
    ** verify difference on ssh command line
    ** push config device 2 to device 1
    ** create backups against, show diffs
    ** verify changes on ssh command line
  .. third device
    * configure third device for internet access
  .. GRE tunnel from lightbulb lab
. Tower
  .. set up credentials
  .. set up inventories
  .. created scheduled jobs
  .. show diffs in Tower
  .. set up notification
  .. do surveys

== About this Lab

This lab will get you started with Ansible Network Automation. As example devices we will use Cisco CSR1000V routers, so most network pros will find their Cisco IOS commands in here. It´s assumed that you understand Ansible´s concepts and have some hands-on knowledge. Otherwise please go through a getting started lab first.

== Your Lab Environment

In the network automation lab you work in a pre-configured lab environment that has already been deployed for you. The lab setup includes a number of hosts:

* Ansible control host - you will run Ansible Engine from here
* Two Cisco CSR1000V routers
* Two RHEL 7 hosts that "sit" behind the Cisco routers

As this is a network automation lab we need a couple of, yes, networks to have some fun. The lab comes with the following networks:

* Management (192.168.0.0/24) - Network between the control host and the Cisco routers.
* Two site networks (192.168.1.0/24 and 192.168.2.0/24) that connect the RHEL 7 hosts and the Cisco routers.
* A Network connecting the Cisco routers to emulate a WAN/"The Internet"

So the Cisco routers come with three network interfaces each. What better then to have drawing of the setup for reference:

image::network_dia.png[]

|===
|Hostname|Mgmt IP|Role
|control.example.com|192.168.0.10|The host you will run Ansible on to manage the other hosts. Only this host is accessible from the Internet.
|csr1.example.com|192.168.0.100|Cisco CSR1000V
|csr2.example.com|192.168.0.110|Cisco CSR1000V
|csr1-host.example.com|192.168.1.200|Site 1 Host
|csr2-host.example.com|192.168.2.200|Site 2 Host
|===

WARNING: You will be able to SSH into the control host, from here you need to connect into the other hosts.

=== Access your Lab Environment

include::access.adoc[]

=== Check the Prerequisites

Most prerequisite tasks have already been done for you:

* Ansible Engine software is installed on `control.example.com`
* A user `ansible` exists on the control host. Please don't run Ansible as `root`. Never.
* The CSR1000V are configured for SSH access with username `admin` and password `cisco`

Check Ansible has been installed correctly on the control host:

----
[root@control ~]# ansible --version
ansible 2.4.2.0
  config file = /root/ansible.cfg
  configured module search path = [u'/root/.ansible/plugins/modules', u'/usr/share/ansible/plugins/modules']
  ansible python module location = /usr/lib/python2.7/site-packages/ansible
  executable location = /usr/bin/ansible
  python version = 2.7.5 (default, May  3 2017, 07:55:04) [GCC 4.8.5 20150623 (Red Hat 4.8.5-14)]
----

NOTE: Ansible is keeping configuration management simple. Ansible requires no database or running daemons and can run easily on a laptop. On the managed hosts it needs no running agent.

Verify that the Cisco routers accept SSH connections with user/password authentication from the control node:
----
[root@control ~]# su - ansible
[ansible@control ~]$ ssh admin@csr1.example.com
Password:

csr1#exit
Connection to csr1.example.com closed.
----

Try this for `csr2.example.com`, too.

NOTE: *In all subsequent exercises you should work as the ansible user on the control node if not explicitly told differently.*

=== Working the Labs

You might have guessed by now this lab is pretty commandline-centric... :-)

* Don't type everything manually, use copy & paste from the browser when appropriate. But don't stop to think and understand... ;-)
* All labs where prepared using Vi, but feel free to install nano or even emacs.

TIP: In the lab guide commands you are supposed to run are shown with or without the expected output, whatever makes more sense in the context.

TIP: The command line can wrap on the web page from time to time. Therefor the output is separated from the command line for better readability by an empty line. *Anyway, the line you should actually run should be recognizable by the prompt.* :-)

=== Challenge Labs

You will soon discover that many chapters in this lab guide come with a "Challenge Lab" section. These labs are meant to give you a small task to solve using what you have learned so far. The solution of the task is shown underneath a warning sign.

== Getting Started with Ansible Network Automation

=== The Inventory

To use Ansible for network automation, you need to provide an inventory file which defines the devices to be managed from the control node. This is basically the same as you would do for "normal" host management. One way to do this is to specify the path to the inventory file with the `-i` option to the ansible command.

Make sure you are user `ansible` on `control.example.com`. Create a directory for your Ansible files:
----
[ansible@control ~]$ mkdir ansible-files
----

Now create a simple inventory file as `~/ansible-files/inventory` with the following content:
----
[csr]
csr1.example.com
csr2.example.com
----

This defines an inventory group `csr` with two member hosts.

To reference inventory hosts, you supply a host pattern to the ansible command. Ansible has a `--list-hosts` option which can be useful for clarifying which managed hosts are referenced by the host pattern in an ansible command.

The most basic host pattern is the name for a single managed host listed in the inventory file. This specifies that the host will be the only one in the inventory file that will be acted upon by the ansible command. Run:

----
[ansible@control ~]$ ansible csr1.example.com -i ~/ansible-files/inventory --list-hosts
hosts (1):
    csr1.example.com
----

Now run Ansible with these host patterns and observe the output:
----
[ansible@control ~]$ ansible csr -i ~/ansible-files/inventory --list-hosts
[ansible@control ~]$ ansible '*.example.com' -i ~/ansible-files/inventory --list-hosts
[ansible@control ~]$ ansible all -i ~/ansible-files/inventory --list-hosts
----

TIP: It is ok to put systems in more than one group, for instance a server could be both a web server and a database server.

TIP: The inventory can contain more data. E.g. if you have hosts that run on non-standard SSH ports you can put the port number after the hostname with a colon. Or you could define names specific to Ansible and have them point to the "real" IP or hostname.

=== The Ansible Configuration Files

The behavior of Ansible can be customized by modifying settings in Ansible's ini-style configuration file. Ansible will select its configuration file from one of several possible locations on the control node, please refer to the documentation.

TIP: The recommended practice is to create an `ansible.cfg` file in a directory from which you run Ansible commands. This directory would also contain any files used by your Ansible project, such as the inventory and Playbooks.

Make sure your inventory file is used by default when executing commands from the `~/ansible-files/` directory:

* On control.example.com as ansible create the file `~/ansible-files/ansible.cfg` with the following content:

----
[defaults]
inventory=/home/ansible/ansible-files/inventory
----

* Check with `ansible --version`, first from ansible's home directory and then from `~/ansible-files/`. You should find when run from `~/ansible-files/` your personal config settings override the main config file settings.
* From `~/ansible-files/` run `ansible all --list-hosts`.

Your Ansible inventory was used without providing the `-i` option. To double-check, run the command again from outside `~/ansible-files/`:

----
[ansible@control ansible-files]$ cd ..
[ansible@control ~]$ ansible all --list-hosts
 [WARNING]: Could not match supplied host pattern, ignoring: all

 [WARNING]: provided hosts list is empty, only localhost is available

 [WARNING]: No hosts matched, nothing to do

  hosts (0):
----

== Ansible Network Automation vs Host Automation

The next step would be to use Ansible to execute tasks on the Cisco devices. But of course we need to set up a connection and access credentials first. As this is done in a different way then "normal" Ansible connections to Linux host, we'll go into some depth here.

=== Ansible for Hosts

When Ansible is used to automate Linux (or UNIX) host configuration, the standard connection method is SSH using key (password-less) authentication. This involves distributing SSH keys to the managed hosts, mainly during intitial host deployment/installation. Ansible would then "compile" all tasks into Python scripts, copy the Python code via SSH to the managed hosts and execute it there.

This is not going to work on network devices for some reasons:

* SSH is not available on all (most?) network devices
* No Python interpreter (or not on all devices)
* Every vendors network device OS works differently

=== So what about network devices?

To talk to network devices Ansible uses either CLI over SSH or API (when available) transports for connections. But the real magic when using Ansible with network devices is in the Ansible modules. The modules are device-specific and "know" how to talk to a certain device type. We will use the `ios_*` modules to talk to our Cisco routers via SSH. Other network modules might require a locally installed CLI software as a connection method.

So the main difference is:

* To a _Linux host_ Ansible would connect _directly_ using the inventory hostname and an SSH connection.
* When configuring a _network device_ Ansible will call the module _locally_, the module then handles the connection to the device. SSH in this lab, but it may be some API or CLI call, too. This happens mostly transparent to the user.

== Configure Connection Settings

Phew, okay. This is out of the way. But how do we pass credentials to a network module? All core networking modules implement a provider argument, which defines the characteristics of how to connect to the device. In the case of our Cisco IOS modules we can configure the transport (aka connection) as a provider in a couple of ways. In this lab we will define the provider with the connection settings as a group variable.

Create the directoy `~/ansible-files/group_vars`:

----
[ansible@control ~]$ mkdir ~/ansible-files/group_vars/
----

Now create the variable file `~/ansible-files/group_vars/csr` with the actual provider configuration (take care of the dashes, this is YAML):

----
---
cisco_connect:
  host: "{{ inventory_hostname }}"
  username: admin
  password: cisco

ansible_connection: local
----

What happens here?

* A transport provider named "cisco_connect" is defined
* The connection settings are configured
* The type of the connection is set to "local"

TIP: These settings can be configured in a number of ways and places, e.g as environment variables. Using the group variables is a good way to stay sane. In addition, please read this: http://docs.ansible.com/ansible/latest/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable

The provider "cisco_connect" can now be used for the inventory group "csr" in ad hoc commands and playbooks.

TIP: Expect the way connection details for networking modules are configured to get a lot more aligned to the way its done with hosts in the next release of Ansible Engine. The "provider" argment that is specific to the networking modules will be replaced by a new "connection" method "network_cli". *As with all things roadmap: No guarantee, of course!*

== Running Ansible Ad-Hoc Commands

Ansible allows administrators to execute on-demand tasks on managed hosts. These ad hoc commands are the most basic operations that can be performed with Ansible. They are great for learning about Ansible, for trying new things or for quick non-intrusive tasks like reporting. Let's try something straight forward:

WARNING: *Don't forget to run the commands from `~/ansible-files/` where your `ansible.cfg` file is located, otherwise it will complain about an empty host list.*

WARNING: If you know Ansible already you might be tempted to run `ansible csr -m ping` after setting up the inventory and everything. While this good practice with regular hosts, it's confusing in this case. Why? Because it will come back with "SUCCESS" from your devices. Remember the *local* connection we configured? This command will just run Ansible's ping against the control host... probably not what you want.

=== Listing Modules and Getting Help

Ansible comes with a lot of modules by default. Think of a module as a tool which is designed to accomplish a specific task. To list all modules run:

----
[ansible@control ansible-files]$ ansible-doc -l
----

TIP: In `ansible-doc` use the `up`/`down` arrows to scroll through the content and leave with `q`.

But in this lab we are only intersted in the modules for IOS devices, right? Use grep to get a list of the IOS modules:
----
[ansible@control ansible-files]$ ansible-doc -l | grep "^ios_"
----

Get help for a specific module including usage examples:
----
[ansible@control ansible-files]$ ansible-doc ios_config
----

TIP: Mandatory options are marked by a "=" in `ansible-doc`.

=== Running Ad Hoc Commands: `ios_command`

Let's start with `ios_command`, this module allows to run IOS commands on your devices. The module is called with `-m` and the options are passed with `-a`. Give it a try:
----
[ansible@control ansible-files]$ ansible csr1.example.com -m ios_command -a 'commands="sh ip int br"'
----

Okay, not too successful, status FAILED. This is because we configured the provider with the connection settings, but we didn't tell the command to use it. Give it a second try, this time supplying the `provider` argument:

----
[ansible@control ansible-files]$ ansible csr1.example.com -m ios_command -a 'commands="sh ip int br" provider={{cisco_connect}}'
----

Now the connection from the module to the Cisco worked and you should get a familiar listing.

TIP: You might be wondering why we have to enclose the provider name in double curly braces. If you have used Ansible before you know this is for referencing variables. And the provider we defined in the group var file is actually a variable structure.

Another example: Have a quick look at the version your host is running:
----
[ansible@control ansible-files]$ ansible csr1.example.com -m ios_command -a 'commands="sh version" provider={{cisco_connect}}'
----

Until now we executed the command on only one host. The real power of automation is to run the same tasks on many hosts/devices at the same time. Just change the target hosts in the commands to `all`or `csr` (in our inventory this is the same right now):

----
[ansible@control ansible-files]$ ansible csr -m ios_command -a 'commands="sh ip int br" provider={{cisco_connect}}'
----

=== Running Ad Hoc Commands: `ios_config`

The `ios_config` module is extremly useful and has a fair number of arguments. It can be used to store, set, compare and check the configuration of IOS devices. The easiest way to use it is to create a full backup of the current `running-config' of your devices to a text file. Run the following ansible command:

----
[ansible@control ansible-files]$ ansible csr -m ios_config -a 'backup=yes provider={{cisco_connect}}'
----

You should get an output that indicates an error on `csr2.example.com`. What the heck? Both devices should be configured in exactly the same way!

If you get into issues like this, it's best to log into the devices and execute what the module would do:

----
[ansible@control ansible-files]$ ssh admin@csr1.example.com
csr1#enable
csr1#show running-config
Building configuration...

Current configuration : 1549 bytes
!
! Last configuration change at 19:13:04 UTC Thu Dec 21 2017 by admin
!
version 16.7
[...]
----

Looks all good, try the same on `csr2.example.com`.

Okay, there is the issue: The second Cisco is configured to require a password for `enable` mode. As it should be.

TIP: Okay, okay, we prepared the devices this way and you might have noticed already from the different shell prompts. Anyway.

==== Authorization

Obviously we need to provide a password to enter privileged mode. For practice first look up the documentation for the module and look for `authorize` and `auth_pass`.

Now we have to pass the credentials to the module for authorization. Basically we just need to specify the arguments:

----
[ansible@control ansible-files]$ ansible csr -m ios_config -a 'backup=yes provider={{cisco_connect}} authorize=yes auth_pass=cisco'
----

TIP: As with the configuration of the connection parameters this will become more aligned with "regular" ansible in 2.5. E.g. there will be a parameter "become_method: enable". *As with all things roadmap: No guarantee*.

Now the configuration backup should have worked on both devices. The backup is written to the directory `backup`. Have a look:

----
[ansible@control ansible-files]$ ll backup/
total 8
-rw-rw-r--. 1 ansible ansible 1600 Jan 15 13:08 csr1.example.com_config.2018-01-15@13:08:11
-rw-rw-r--. 1 ansible ansible 1650 Jan 15 13:08 csr2.example.com_config.2018-01-15@13:08:11
----

TIP: You could easily use this to do regular backups of your device configurations. One thing to keep in mind though: Ansible by default deletes older files for the same host even while they are timestamped.

As we have seen the configuration of the two devices should be different and we should be able to find this in the configuration backup. Have a quick look (your file names will differ):

----
[ansible@control ansible-files]$ diff -u backup/csr1.example.com_config.2018-01-15\@13\:47\:31 backup/csr2.example.com_config.2018-01-15\@13\:47\:31
----

So this might be useful to keep track of your devices configuration and to do quick comparisons.

=== Challenge Lab: Ad Hoc Commands

How about adding a login banner to our CSRs?

* Find a module and its parameters to do so (Hint: grep docs for "banner"...)
* Use it in an ad hoc command to set the banner to "Managed by Ansible"
* Check that it works by SSHing into the devices
* Delete the banner again from the device

WARNING: *Solution below!*

----
[ansible@control ansible-files]$ ansible csr -m ios_banner -a 'banner=login text="Managed by Ansible!" state=present provider={{ cisco_connect }}'
----
----
[ansible@control ansible-files]$ ansible csr -m ios_banner -a 'banner=login text="Managed by Ansible!" state=absent provider={{ cisco_connect }}'
----

== Ansible Network Automation: Facts

Ansible facts are variables that are automatically discovered by Ansible from a managed host or in our case a network device. On hosts the `setup` module is used to pull facts, on network devices specific modules exist. Regardless how facts are pulled they contain useful information stored into variables that administrators can reuse for example in Playbooks.

=== Using `ios_facts`

We have already used some of the `ios_*` Ansible modules specific to devices running Cisco IOS. To get an idea what facts this module collects by default, on `control.example.com` as user ansible from the `~/ansible-files/` directory run:

----
[ansible@control ansible-files]$ ansible csr -m ios_facts -a 'provider={{cisco_connect}} authorize=yes auth_pass=cisco'
----

This command:

* uses the `ios_facts` module (`-m`)
* uses the settings from the `cisco_connect` provider/connection
* authenticates the `enable` mode

Have a look at the facts provided. The `ios_facts` module differentiates between subsets of data, namely:

* `all`
* `hardware`
* `config`
* `interfaces`

Subsets can be specified as a list, an initial `!` can be used to not collect data for this subset.

WARNING: The facts module does not support the `filter` argument you might know from the `setup` module used to collect host facts.

=== Challenge Lab: Facts

Use `ansible-doc` to look up the modules documentation.

* Which subset is excluded by default?
* Find the parameter to specify subsets.
* Change the command to print the facts for the subsets `interfaces` and `config`.

TIP: In ad hoc commands lists are specified using comma separation.

WARNING: *Solution below!*

* `config` is excluded by default
* The parameter is named `gather_subset`

----
[ansible@control ansible-files]$ ansible csr -m ios_facts -a 'gather_subset=interfaces,config provider={{cisco_connect}} authorize=yes auth_pass=cisco'
----


== Using Ansible Playbooks for Network Automation

While Ansible ad hoc commands are useful for simple operations, they are not suited for complex configuration management or orchestration scenarios.

Playbooks are files which describe the desired configurations or steps to implement on managed hosts. Playbooks can change lengthy, complex administrative tasks into easily repeatable routines with predictable and successful outcomes.

TIP: Here is a nice analogy: When Ansible modules are the tools in your workshop, the inventory is the materials and the Playbooks are the instructions.

The next chapter requires some working knowledge with creating edit running Playbooks.

=== Playbook: Check Configuration

We found the configuration of `csr2.example.com` differs from `csr1.example.com` by executing ad hoc commands and using the `diff` utility on the command line. So first let's convert this into an Ansible Playbook that checks the running-config state of a router against a master configuration.

Remember:

* The connection parameters/settings are defined as a data structure in the `group_vars` file `csr`
* The settings are used using the network modules `provider` parameter

==== Create the Playbook

Create the file `~/ansible-files/check_config.yml` and add this content:

----
---
- name: check router configuration
  hosts: csr
  connection: local
  gather_facts: no

  tasks:
  - name: check the running-config against master config
    ios_config:
      provider: "{{ cisco_connect }}"
      diff_against: intended
      intended_config: "{{ lookup('file', 'master.cfg') }}"
----

What does it do?

* Runs against all devices in the `csr` inventory group
* Configures the `ios_config` module to:
** use the connection settings from the `cisco_connect` variable
** diff the running-config (`diff_against: intended`) against a master configuration defined in a local file (`intended_config`).

Please have a look at the module options in `ansible-docs ios_config` to get familiar with the docs.

We need a master configuration file. Because we want `csr2.example.com` to be the reference configuration copy the backup file we captured in the ad hoc chapter:

----
[ansible@control ansible-files]$ cp ~/ansible-files/backup/csr2.example.com_config.<TIMESTAMP> master.cfg
----

==== Run the Playbook

----
[ansible@control ansible-files]$ ansible-playbook --diff check_config.yml
----

TIP: The `--diff` option is not too commonly used in Playbook runs but needed here!

You should get an error for `csr2.example.com`. The error is not to easy to pin down but wait, didn't we have to pass credentials for `enable` on `csr2.example.com`? Using the ad hoc command we passed the credentials on the commandline, to make it available to the Playbook we'll now put them into the `group_vars` file.

Change `~/ansible-files/group_vars/csr` to look like:

----
---
cisco_connect:
  host: "{{ inventory_hostname }}"
  username: admin
  password: cisco
  auth_pass: cisco
  authorize: true
ansible_connection: local
----

Now run the Playbook again. The output should nicely show the diff of the devices to the master configuration. `csr2.example.com` should show as OK (no surprise I would say) but `csr1.example.com` should show a good number of changes.

==== Challenge Lab

This is handy, but a number of configuration lines are shown as diffs that have to be different, like `ip address` or `hostname`. The `ios_config` module knows an option to specify one or more lines that should be ignored during the diff.

* Look up the module doc and find the option name
* Change the Playbook to ignore lines you don't want to have listed (e.g. `ip address` or `hostname`)

[TIP]
====
The argument takes a YAML list with regular expressions, e.g.:
----
<option>:
  - line .*
  - another line .*
----
====

* Run the Playbook. As a result the specified line patterns should be excluded from the diff.

WARNING: *Solution below!*

----
diff_ignore_lines:
        - hostname .*
        - ip address .*
        - license .*
        - user name .*
----

=== Playbook: Configure Router

Now that we know `csr1.example.com` is not configured correctly let us fix this. We have the (correct) configuration from `csr2.example.com` saved as master config file. We could just use the `ios_config` modul and apply the master configuration file to `csr1`.

But wait! There are some config settings in there that have to be specific to the device like hostname, ip configuration and so on. You don't really want to have all your devices with the same IP, do you?

==== Creating the Configuration Template

Luckily Ansible can use Jinja2 templating to modify files before they are distributed to managed devices.

So let's convert the `master.cfg` file to a template to be used with our CSR routers. First clean up the file a bit and rename it to show it's a template:

----
[ansible@control ansible-files]$ cat master.cfg | grep -v "!" > master_csr_config.j2
----

Delete the first couple of lines in `master_csr_config.j2`:

----
Building configuration...

Current configuration : 1590 bytes
version 16.7
----

That's better. Now the important part: We want to replace some commands (or part of them) with variables. Open the file in your editor and edit the hostname and ip configuration commands to look like this:

----
[...]
hostname {{ hostname }}
[...]
interface GigabitEthernet1
 {{ gi1 }}
[...]
interface GigabitEthernet2
 {{ gi2 }}
[...]
interface GigabitEthernet3
 {{ gi3 }}
[...]
----

TIP: You might wonder why we define the whole `ip address ...` line but only the value for the hostname as a variable... you'll see in a second.

Before we write the Playbook we need to define the values somewhere. Remember how we defined the connection variables in the `group_vars/csr` file? We can do the same for individual hosts in `host_vars` files.

First create the `host_vars` directory:

----
[ansible@control ansible-files]$ mkdir ~/ansible-files/host_vars/
----

Then create the file `~/ansible-files/host_vars/csr1.example.com` with these lines:

----
---
hostname: csr1
gi1: "ip address 192.168.0.100 255.255.255.0"
gi2: "ip address 192.168.1.100 255.255.255.0"
gi3: "no ip address"
----

TIP: Now it should become clear why we structured the template like we did.

==== Creating the Playbook

Now we have to create a Playbook to apply the configuration template. Create `~/ansible-files/configure_csr.yml`:

----
---
- name: configure csr from master config template
  hosts: csr1.example.com
  connection: local
  gather_facts: no

  tasks:
  - name: create and apply config from master template
    ios_config:
      provider: "{{ cisco_connect }}"
      src: master_csr_config.j2
      #save_when: always
      match: none
----

What happens here?

* The `ios_config` module is used to deploy a configuration defined in the `src` parameter.
* The `match` parameter is set to `none`, meaning the modul will not compare the source with the device configuration.
* The `save_when` parameter defined if and when the changed `running-config` will be copied to the `startup-config`.

==== Running the Playbook

Now run the Playbook, but be careful. It's easy to see how you could accidentally deploy this configuration on all devices managed by Ansible. It's about automation after all, this includes wiping out configurations as well...

There are a lot of ways to structure inventories and Playbooks to avoid this, for now we'll just check the devices the Playbook will actually be run against. Should of course just be the host from the `hosts:` line but better safe then sorry. So run:

----
[ansible@control ansible-files]$ ansible-playbook --list-hosts configure_csr.yml

playbook: configure_csr.yml

  play #1 (csr1.example.com): configure csr from master config template	TAGS: []
    pattern: [u'csr1.example.com']
    hosts (1):
      csr1.example.com
----

Looks good!

Okay, go ahead and run it:

----
[ansible@control ansible-files]$ ansible-playbook configure_csr.yml
----

To test our work, SSH into `csr1.example.com`. Then try to run `enable`, it should ask for a password now. Compare the `running-config` with the `startup-config`, it should still differ.

To fix the `startup-config` uncomment the `save_when` line and run the Playbook again. Check the result.

TIP: The `ios_config` module is something like the Swiss Army Knife for IOS devices. It can do a lot more like comparing configs, doing backups, changing only lines or sections of an configurations etc. If in doubt, read the great documentation.

=== Playbook: Create a Report

In this example we'll use Ansible's templating mechanism to create a nice HTML report from the facts Ansible collects from the managed devices.

We need two things for this:

* A Jinja2 template to produce the HTML output
* A Playbooks that collects the facts and fills the template

==== The template

Let's start with the template. Jinja2 templating is very powerful and comes with a lot of options, if you want to learn more it's best to look up the documentation.

Create the file `~/ansible-files/report_ios.j2`:

----
 <!DOCTYPE html>
<html>
<head>
</head>
<body>
<table>
    <thead>
        <tr>
            <th>Hostname</th>
            <th>Model Type</th>
            <th>Serial Number</th>
            <th>Mgmt interface IP</th>
            <th>Code Version</th>
        </tr>
    </thead>
    <tbody>
{% for device in groups['csr'] %}
        <tr>
            <td>{{hostvars[device]['ansible_net_hostname']}}</td>
            <td>{{hostvars[device]['ansible_net_model']}}</td>
            <td>{{hostvars[device]['ansible_net_serialnum']}}</td>
            <td>{{hostvars[device]['ansible_net_interfaces']['GigabitEthernet1']['ipv4'][0]['address']}}</td>
            <td {% if hostvars[device]['ansible_net_version'] != desired_ios_version %}style="background:yellow;"{% endif %}>{{hostvars[device]['ansible_net_version']}}</td>
        </tr>
{% endfor %}
    </tbody>
</table>

</body>
</html>
----

So what is this template doing?

* Easy to spot; it generates an HTML page with a table
* The interesting parts are the Jinja2 bits, commands are enclosed in `{% ... %}`
* The content of the facts is referenced as variables: `{{...}}`

With this in mind it's easy to understand what's going on:

* A loop is going over all devices in the `csr` inventory group
* For every device is constructs a table row with a number of fields that get filled with variables.
* To make this a bit more entertaining we change the color in one field if the value from `desired_ios_version` is not matched.

TIP: To understand how the facts data structure is referenced here, have a look at the facts output you run earlier.

==== The Playbook

Now we need a Playbook to collect the facts and to write the HTML file based on the template. Create the file `~/ansible-files/report_ios.yml`:

----
---
  - name: build IOS inventory
    hosts: csr
    connection: local
    gather_facts:  False

    vars:
       desired_ios_version: "16.06.01"

    tasks:

      - name: gathering IOS facts
        ios_facts:
          provider: "{{ cisco_connect }}"
        register: all_facts

      - name: create HTML report
        template:
          src: report_ios.j2
          dest: ./report_ios.html
        delegate_to: localhost
        run_once: true
----

Let's go through this:

* A variable `desired_ios_version` is set to a string, this is used for setting the color of the version field.
* Then the facts are collected from the devices and registered for later use.
* And finally Ansible's template module is run with the template as source.

Little challenge: Why do we need `delegate_to` and `run_once` here?

TIP: Beacuse we want the file to be created on our control node and we want this task only run once and not for every device.

==== Run the Report

Before we actually run the Playbook change the template to look like this (e.g. add the `<style>` section):

----
<!DOCTYPE html>
<html>
<head>
<style>
* {
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
	box-sizing: border-box;
}

body {
  background:#353a40;
}

table {
  border-collapse: separate;
  background:#fff;
  @include border-radius(5px);
  margin:50px auto;
  @include box-shadow(0px 0px 5px rgba(0,0,0,0.3));
}

thead {
  @include border-radius(5px);
}

thead th {
  font-family: 'Patua One', monospace;
  font-size:16px;
  font-weight:400;
  color:#fff;
  @include text-shadow(1px 1px 0px rgba(0,0,0,0.5));
  text-align:left;
  padding:20px;
  border-top:1px solid #858d99;
  background: #353a40;

  &:first-child {
   @include border-top-left-radius(5px);
  }

  &:last-child {
    @include border-top-right-radius(5px);
  }
}

tbody tr td {
  font-family: 'Open Sans', sans-serif;
  font-weight:400;
  color:#5f6062;
  font-size:13px;
  padding:20px 20px 20px 20px;
  border-bottom:1px solid #e0e0e0;

}

tbody tr:nth-child(2n) {
  background:#f0f3f5;
}

tbody tr:last-child td {
  border-bottom:none;
  &:first-child {
    @include border-bottom-left-radius(5px);
  }
  &:last-child {
    @include border-bottom-right-radius(5px);
  }
}

span.highlight {
    background-color: yellow;
}
</style>
</head>
<body>
<table>
    <thead>
        <tr>
            <th>Hostname</th>
            <th>Model Type</th>
            <th>Serial Number</th>
            <th>Mgmt interface IP</th>
            <th>Code Version</th>
        </tr>
    </thead>
    <tbody>
{% for device in groups['csr'] %}
        <tr>
            <td>{{hostvars[device]['ansible_net_hostname']}}</td>
            <td>{{hostvars[device]['ansible_net_model']}}</td>
            <td>{{hostvars[device]['ansible_net_serialnum']}}</td>
            <td>{{hostvars[device]['ansible_net_interfaces']['GigabitEthernet1']['ipv4'][0]['address']}}</td>
            <td {% if hostvars[device]['ansible_net_version'] != desired_ios_version %}style="background:yellow;"{% endif %}>{{hostvars[device]['ansible_net_version']}}</td>
        </tr>
{% endfor %}
    </tbody>
</table>

</body>
</html>
----

TIP: In real life you would have some mechanism to make the resulting HTML page available on a webserver and keep the css in a separate file, of course. For the purpose of this lab we just embed it.

Okay, let's run the Playbook:

----
[ansible@control ansible-files]$ ansible-playbook report_ios.yml
----

If everything went fine you should now have the file `report_ios.html` in the same folder. To make it available to your browser do the following steps:

----
[ansible@control ansible-files]$ exit
logout
[root@control ~]# cp /home/ansible/ansible-files/report_ios.html /var/www/html/
----

Now go and open `\http://<control hostname or ip>/report_ios.html` in your browser. Cool, isn't it?

TIP: This lab is based on `\https://github.com/network-automation/ansible_inventory_report`. Have a look, there is lot more great examples to be found!

==== Challenge Lab: Change the Report

* Change the reporting so the version is not displayed yellow (so the desired version is the version your CSRs are actually running)
* Make other facts available in the report, what about having the total memory in the report, too?

WARNING: *Solution Below!*

* Change the Playbook variable to `desired_ios_version: "16.07.01"`
* Add a field to the table head:
----
<th>Memory</th>
----
* Add a field to the table row:
----
<td>{{hostvars[device]['ansible_net_memtotal_mb']}}</td>
----
